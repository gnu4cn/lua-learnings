# 垃圾回收

**Garbage**


Lua 会进行自动的内存管理。程序可以创建出对象（表、闭包等），却没有删除对象的功能。Lua 会使用 *垃圾回收，garbage collection*，自动删除成为了垃圾的对象。这使我们摆脱了内存管理的大部分负担，更重要的是，使我们摆脱了与内存管理相关的大部分错误，如悬空指针及内存泄漏等，dangling pointers and memory leaks。


在一种理想世界中，程序员是看不到垃圾回收器的，the garbage collector，他就像个优秀的清洁工，不会干扰其他工作人员的工作。不过，有时即使是更聪明的垃圾回收器，也需要我们的帮助。我们可能需要在某些性能关键时刻，停止他工作，或者只允许他在某些特定时间工作。此外，垃圾回收器只能回收他能确定是垃圾的东西，而不能猜度我们认为什么是垃圾。没有垃圾回收器，我们就无法摆脱资源管理方面的所有烦恼，比如内存和外部资源的囤积等，hoarding memory and external resources。


弱表，weak tables、终结器，finalizers，和函数 `collectgarbage` 三者，是我们在 Lua 中，帮助垃圾回收器可以使用的主要机制。弱表实现对程序仍可访问 Lua 对象的回收；终结器实现对不受垃圾回收器直接控制外部对象的回收。函数 `collectgarbage` 则允许我们控制垃圾回收器的运行速度。在本章中，我们将讨论这些机制。



## 弱表

**Weak Tables**


正如我们曾说过的，垃圾回收器不能猜度我们认为的垃圾是什么。典型例子就是堆栈，他是通过一个数组，以及一个指向顶部的索引实现的。我们知道，数组的有效部分只会到顶部，但 Lua 却不知道。如果我们通过简单地递减顶层索引，来弹出一个元素，那么对 Lua 来说，数组中剩下的对象就不是垃圾。同样，存储在某个全局变量中的任何对象，对 Lua 来说都不是垃圾，即使咱们的程序永远不再用到他。在这两种情况下，我们（即我们的程序）都需要为这些位置赋值 `nil`，这样他们就不会锁定本可丢弃的对象。


然而，只是清理咱们的引用，并非总是足够了。有的结构就需要程序和回收器之间，额外的协作。典型例子便是，当我们想要保留程序中某种存活对象（如文件）列表时。此任务看似简单：我们只需将每个新对象，插入该列表即可。但是，一旦对象成为该列表的一部分，他就永远不会被回收！即使没有其他对象指向他，列表也会指向他。除非我们告诉 Lua 没有对象指向他这一事实，否则 Lua 就无法知道，列表指向他这一引用，不应阻止该对象的回收。


弱表正是我们用来告诉 Lua，某个引用不应阻止对象回收的机制。*弱引用，weak reference* 是种垃圾回收器不会考虑的对象引用。如果指向某个对象的全部引用都是弱引用，那么垃圾回收器就会回收该对象，并删除这些弱引用。Lua 通过 *弱表*，实现的弱引用：弱表是种其条目均为弱条目的表。这意味着，如果某个对象只存在于弱表中，那么 Lua 最终将回收该对象。


表有着键与值，两者均可包含任何类型对象。正常情况下，垃圾回收器不会回收作为键或值，出现在某个可访问表中的对象。也就是说，键和值都是强引用，因为他们可以防止回收他们所引用的对象。在弱表中，键和值都可以是弱引用。这就意味着有三种弱表：键为弱的表、值为弱的表以及键和值都为弱的表。不管是哪种表，当键或值被回收时，整个条目都会从表中消失。


??? from here until ???END lines may have been inserted/deleted
表的弱性，是由其元表中的 `__mode` 字段所给出的。如果该字段存在且值为 `"k"`，则表中的键为弱键；如果该字段值为 `"v"`，则表中的值为弱值；如果该字段值为 `"kv"`，则键和值都为弱值。下面的示例虽然是杜撰的，却说明了弱表的基本行为：


```lua
a = {}
mt = {__mode = "k"}
setmetatable(a, mt)     -- 现在 'a' 就有了弱键
key = {}                -- 创建出首个键
a[key] = 1
key = {}                -- 创建出第二个键
a[key] = 2
collectgarbage()        -- 强制进行一次垃圾回收周期
for k, v in pairs(a) do print(v) end
    --> 2
```

在这个示例中，第二个赋值 `key = {}` 覆盖了第一个 `key` 的引用。对 `collectgarbage` 的调用，会强制垃圾回收器进行一次完整的回收。由于不再有其他的对第一个键引用，Lua 就会回收这个键并删除该表中的相应条目。然而，第二个键仍锚定在变量 `key` 中，因此 Lua 不会回收他。


请注意，只有对象才能从弱表中删除。数字和布尔值等值，就不能被回收。例如，如果我们往这个表 `a` （上一示例中），插入一个数字键，那么收集器就永远不会删除他。当然，如果某个数字键对应的值，在某个有着弱值的表中被回收了，那么整个条目就会从该表中被移除。


在这里，字符串有个微妙之处：虽然从实现角度看，字符串是可回收的，但他们却与其他可回收对象不同。其他对象，如表和闭包，都是显式创建的。例如，每当 Lua 计算表达式 `{}` 时，他都会创建一个新表。但是，Lua 在计算 `"a".."b"` 时，会不会创建出新的字符串呢？如果系统中已经有个字符串 `"ab"` 会怎么办呢？Lua 是否会创建一个新的字符串？编译器能否在运行程序之前，创建这个字符串呢？这并不重要：这些都是实现细节。从程序员角度来看，字符串是值，而非对象。因此，与数字或布尔值一样，字符串键不会从弱表中删除，除非其关联的值被回收。


## 记忆函数

**Memorize Functions**


以空间换取时间，是种常见编程技巧。通过 *记住* 某个函数的结果，在以后我们用相同参数调用该函数时，这个函数就可以重复使用该结果[<sup>1</sup>](#footnote_184-1)，如此我们就可以加快某个函数的运行。

<a name="footnote_184-1"><sup>1</sup></a> 尽管 “memorize”（记忆）这一既定的英文单词，恰好描述了我们想要做的事情，但编程界还是创造了个新词 -- *memoize*（记忆）-- 来描述这一技术。我（作者）将坚持使用原词。

设想某个通用服务器正以 Lua 代码，接收着字符串形式的请求。其每次收到请求时，他都会在该字符串上运行 `load` 函数，然后调用生成的函数。然而，`load` 是个开销昂贵的函数，且服务器收到的某些命令可能相当频繁。服务器无需在每次收到像是 `"closeconnection()"` 这样的常见命令时，重复调用 `load`，而是可以使用一个辅助表，来 *记住* `load` 的结果。在调用 `load` 前，服务器会在该表中检查给定字符串是否已有转译。若找不到匹配的结果，服务器就会调用 `load`，并将结果存储到该表中。我们可以将这种行为，打包到一个新函数中：


```lua
local results = {}
function mem_loadstring (s)
    local res = results[s]
    if res == nil then                  -- 结果不存在？
        res = assert(load(s))           -- 计算新的结果
        results[s] = res                -- 保存用于后面的重用
    end
    return res
end
```

这种方案下可以节省大量开销。不过，他也可能造成意想不到的浪费。虽然有些命令会反复出现，但许多其他命令却只会出现一次。逐渐地，表 `results` 会累积下服务器收到过的所有命令及其各自的代码；足够长的时间后，这种行为会耗尽服务器内存。


弱值表为这一问题提供了一种简单解决方案。如果 `results` 表有着弱值，那么每个垃圾回收周期都会删除当时未用到所有转译（这意味着几乎所有转移）：


```lua
local results = {}
setmetatable(results, {__mode = "v"})   -- 使值成为弱值
function mem_loadstring (s)
    as before
```

实际上，由于该表的索引始终是字符串，因此如果我们愿意，可以让这个表完全弱化：

```lua
setmetatable(results, {__mode = "kv"})
```

最终（净）结果是一样的，the net result is the same。


这种记忆技巧，对于确保某种对象的唯一性也很有用。例如，假设某个系统以表的形式表示颜色，其中的 `red`、`green`、`blue` 字段在一定范围内。那么一个简单的颜色工厂，就会为每个新请求生成一种新颜色：

```lua
function createRGB (r, g, b)
    return {red = r, green = g, blue = b}
end
```

运用记忆术，我们可以对相同颜色重用同一个表。要为每种颜色创建一个唯一键，我们只需将颜色索引连接起来，其间用分隔符隔开即可：


```lua
local results = {}
setmetatable(results, {__mode = "v"})   -- 使值成为弱值
function createRGB (r, g, b)
    local key = string.format("%d-%d-%d", r, g, b)
    local color = results[key]
    if color == nil then
        color = {red = r, green = g, blue = b}
        results[key] = color
    end
    return color
end
```

这种实现方式的一个有趣结果是，用户可以使用原始相等运算符，the primitive equality operator，`==`，来比较颜色，这是因为两种共存的相等颜色，总是由同一个表来表示的。任何给定颜色，都可以在不同时间由不同表来表示，因为垃圾回收器会不时清除那个 `results` 表。不过，只要给定颜色仍在使用中，其就不会从 `results` 中删除。因此，只要某种颜色存活时间足够长，其就可以与某种新的颜色进行比较，其的表示也就存活了足够长的时间，可以被新颜色重用。


## 对象的属性

**Object Attributes**



