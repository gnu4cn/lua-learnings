# 垃圾回收

**Garbage**


Lua 会进行自动的内存管理。程序可以创建出对象（表、闭包等），却没有删除对象的功能。Lua 会使用 *垃圾回收，garbage collection*，自动删除成为了垃圾的对象。这使我们摆脱了内存管理的大部分负担，更重要的是，使我们摆脱了与内存管理相关的大部分错误，如悬空指针及内存泄漏等，dangling pointers and memory leaks。


在一种理想世界中，程序员是看不到垃圾回收器的，the garbage collector，他就像个优秀的清洁工，不会干扰其他工作人员的工作。不过，有时即使是更聪明的垃圾回收器，也需要我们的帮助。我们可能需要在某些性能关键时刻，停止他工作，或者只允许他在某些特定时间工作。此外，垃圾回收器只能回收他能确定是垃圾的东西，而不能猜度我们认为什么是垃圾。没有垃圾回收器，我们就无法摆脱资源管理方面的所有烦恼，比如内存和外部资源的囤积等，hoarding memory and external resources。


弱表，weak tables、终结器，finalizers，和函数 `collectgarbage` 三者，是我们在 Lua 中，帮助垃圾回收器可以使用的主要机制。弱表实现对程序仍可访问 Lua 对象的回收；终结器实现对不受垃圾回收器直接控制外部对象的回收。函数 `collectgarbage` 则允许我们控制垃圾回收器的运行速度。在本章中，我们将讨论这些机制。



## 弱表

**Weak Tables**


正如我们曾说过的，垃圾回收器不能猜度我们认为的垃圾是什么。典型例子就是堆栈，他是通过一个数组，以及一个指向顶部的索引实现的。我们知道，数组的有效部分只会到顶部，但 Lua 却不知道。如果我们通过简单地递减顶层索引，来弹出一个元素，那么对 Lua 来说，数组中剩下的对象就不是垃圾。同样，存储在某个全局变量中的任何对象，对 Lua 来说都不是垃圾，即使咱们的程序永远不再用到他。在这两种情况下，我们（即我们的程序）都需要为这些位置赋值 `nil`，这样他们就不会锁定本可丢弃的对象。


然而，只是清理咱们的引用，并非总是足够了。有的结构就需要程序和回收器之间，额外的协作。典型例子便是，当我们想要保留程序中某种存活对象（如文件）列表时。此任务看似简单：我们只需将每个新对象，插入该列表即可。但是，一旦对象成为该列表的一部分，他就永远不会被回收！即使没有其他对象指向他，列表也会指向他。除非我们告诉 Lua 没有对象指向他这一事实，否则 Lua 就无法知道，列表指向他这一引用，不应阻止该对象的回收。


弱表正是我们用来告诉 Lua，某个引用不应阻止对象回收的机制。*弱引用，weak reference* 是种垃圾回收器不会考虑的对象引用。如果指向某个对象的全部引用都是弱引用，那么垃圾回收器就会回收该对象，并删除这些弱引用。Lua 通过 *弱表*，实现的弱引用：弱表是种其条目均为弱条目的表。这意味着，如果某个对象只存在于弱表中，那么 Lua 最终将回收该对象。


表有着键与值，两者均可包含任何类型对象。正常情况下，垃圾回收器不会回收作为键或值，出现在某个可访问表中的对象。也就是说，键和值都是强引用，因为他们可以防止回收他们所引用的对象。在弱表中，键和值都可以是弱引用。这就意味着有三种弱表：键为弱的表、值为弱的表以及键和值都为弱的表。不管是哪种表，当键或值被回收时，整个条目都会从表中消失。


??? from here until ???END lines may have been inserted/deleted
表的弱性，是由其元表中的 `__mode` 字段所给出的。如果该字段存在且值为 `"k"`，则表中的键为弱键；如果该字段值为 `"v"`，则表中的值为弱值；如果该字段值为 `"kv"`，则键和值都为弱值。下面的示例虽然是杜撰的，却说明了弱表的基本行为：


```lua
a = {}
mt = {__mode = "k"}
setmetatable(a, mt)     -- 现在 'a' 就有了弱键
key = {}                -- 创建出首个键
a[key] = 1
key = {}                -- 创建出第二个键
a[key] = 2
collectgarbage()        -- 强制进行一次垃圾回收周期
for k, v in pairs(a) do print(v) end
    --> 2
```

在这个示例中，第二个赋值 `key = {}` 覆盖了第一个 `key` 的引用。对 `collectgarbage` 的调用，会强制垃圾回收器进行一次完整的回收。由于不再有其他的对第一个键引用，Lua 就会回收这个键并删除该表中的相应条目。然而，第二个键仍锚定在变量 `key` 中，因此 Lua 不会回收他。


请注意，只有对象才能从弱表中删除。数字和布尔值等值，就不能被回收。例如，如果我们往这个表 `a` （上一示例中），插入一个数字键，那么收集器就永远不会删除他。当然，如果某个数字键对应的值，在某个有着弱值的表中被回收了，那么整个条目就会从该表中被移除。


在这里，字符串有个微妙之处：虽然从实现角度看，字符串是可回收的，但他们却与其他可回收对象不同。其他对象，如表和闭包，都是显式创建的。例如，每当 Lua 计算表达式 `{}` 时，他都会创建一个新表。但是，Lua 在计算 `"a".."b"` 时，会不会创建出新的字符串呢？如果系统中已经有个字符串 `"ab"` 会怎么办呢？Lua 是否会创建一个新的字符串？编译器能否在运行程序之前，创建这个字符串呢？这并不重要：这些都是实现细节。从程序员角度来看，字符串是值，而非对象。因此，与数字或布尔值一样，字符串键不会从弱表中删除，除非其关联的值被回收。


## 记忆函数

**Memorize Functions**


以空间换取时间，是种常见编程技巧。通过 *记住* 某个函数的结果，在以后我们用相同参数调用该函数时，这个函数就可以重复使用该结果[<sup>1</sup>](#footnote_184-1)，如此我们就可以加快某个函数的运行。

<a name="footnote_184-1"><sup>1</sup></a> 尽管 “memorize”（记忆）这一既定的英文单词，恰好描述了我们想要做的事情，但编程界还是创造了个新词 -- *memoize*（记忆）-- 来描述这一技术。我（作者）将坚持使用原词。

设想某个通用服务器正以 Lua 代码，接收着字符串形式的请求。其每次收到请求时，他都会在该字符串上运行 `load` 函数，然后调用生成的函数。然而，`load` 是个开销昂贵的函数，且服务器收到的某些命令可能相当频繁。服务器无需在每次收到像是 `"closeconnection()"` 这样的常见命令时，重复调用 `load`，而是可以使用一个辅助表，来 *记住* `load` 的结果。在调用 `load` 前，服务器会在该表中检查给定字符串是否已有转译。若找不到匹配的结果，服务器就会调用 `load`，并将结果存储到该表中。我们可以将这种行为，打包到一个新函数中：


```lua
local results = {}
function mem_loadstring (s)
    local res = results[s]
    if res == nil then                  -- 结果不存在？
        res = assert(load(s))           -- 计算新的结果
        results[s] = res                -- 保存用于后面的重用
    end
    return res
end
```

这种方案下可以节省大量开销。不过，他也可能造成意想不到的浪费。虽然有些命令会反复出现，但许多其他命令却只会出现一次。逐渐地，表 `results` 会累积下服务器收到过的所有命令及其各自的代码；足够长的时间后，这种行为会耗尽服务器内存。


弱值表为这一问题提供了一种简单解决方案。如果 `results` 表有着弱值，那么每个垃圾回收周期都会删除当时未用到所有转译（这意味着几乎所有转移）：


```lua
local results = {}
setmetatable(results, {__mode = "v"})   -- 使值成为弱值
function mem_loadstring (s)
    as before
```

实际上，由于该表的索引始终是字符串，因此如果我们愿意，可以让这个表完全弱化：

```lua
setmetatable(results, {__mode = "kv"})
```

最终（净）结果是一样的，the net result is the same。


这种记忆技巧，对于确保某种对象的唯一性也很有用。例如，假设某个系统以表的形式表示颜色，其中的 `red`、`green`、`blue` 字段在一定范围内。那么一个简单的颜色工厂，就会为每个新请求生成一种新颜色：

```lua
function createRGB (r, g, b)
    return {red = r, green = g, blue = b}
end
```

运用记忆术，我们可以对相同颜色重用同一个表。要为每种颜色创建一个唯一键，我们只需将颜色索引连接起来，其间用分隔符隔开即可：


```lua
local results = {}
setmetatable(results, {__mode = "v"})   -- 使值成为弱值
function createRGB (r, g, b)
    local key = string.format("%d-%d-%d", r, g, b)
    local color = results[key]
    if color == nil then
        color = {red = r, green = g, blue = b}
        results[key] = color
    end
    return color
end
```

这种实现方式的一个有趣结果是，用户可以使用原始相等运算符，the primitive equality operator，`==`，来比较颜色，这是因为两种共存的相等颜色，总是由同一个表来表示的。任何给定颜色，都可以在不同时间由不同表来表示，因为垃圾回收器会不时清除那个 `results` 表。不过，只要给定颜色仍在使用中，其就不会从 `results` 中删除。因此，只要某种颜色存活时间足够长，其就可以与某种新的颜色进行比较，其的表示也就存活了足够长的时间，可以被新颜色重用。


## 对象属性

**Object Attributes**


弱表的另一重要用途，是将属性与对象关联起来。很多情况下，我们都需要为对象附加一些属性：函数的名字、表格的默认值及数组的大小等等。

当对象是个表时，我们就可以适当的唯一键，在表中存储属性。(正如我们之前所看到的，创建唯一键的一种简单且不会出错的方法，便是创建一个新表并将其作为键）。但是，如果对象不是表，其就不能保留自己的属性。即使是表，有时我们可能也不想在原始对象中存储属性。例如，我们可能打算将属性保持私有，或者不想让属性干扰表的遍历等等。在所有这些情况下，我们就需要某种将属性映射到对象的替代方法。


当然，外部表提供了一种将属性映射到对象的理想方式。这就是我们在 [“双重表示法”](oop.md#双重表示法) 小节中，所说的 *双重表示法，dual representation*。我们将对象用作键，将其属性作为值。由于 Lua 允许我们使用任何类型对象作为键，因此外部表就可以保存任何类型对象的属性。此外，外部表中保存的属性，还不会干扰其他对象，并且可以像表本身一样私有。


然而，这个看似完美的解决方案，却有个巨大的缺陷：一旦我们将某个对象用作某个表的键，我们就会锁定该对象的存在。Lua 无法回收被用作键的对象。例如，如果我们使用某个常规表，将函数映射到他们的名字，那么这些函数将永远不会被回收。正如咱们所料，我们可以通过使用弱表，来避免这一缺点。不过，这次我们需要弱键。弱键的使用，不会阻止任何键被回收，直到没有对该键的任何引用，the use of weak keys does not prevent any key from being collected, once there are no other references to it。另一方面，该表不能有弱值；否则，存活对象的属性会被回收掉。


## 重温带默认值的表

**Revisiting Tables with Default Values**


在名为 [带默认值的表](metatables_and_metamethods.md#带默认值的表) 小节，我们讨论过如何实现带非空，non-nil，缺省值的表。我们曾见识到一种特别技巧，并提到另外两种技巧需要用到弱表，因此我们推迟了对这两种技巧的讨论。现在是重新讨论这个问题的时候了。我们将看到，这两种缺省值技巧，实际上是我们刚讨论过的两种一般技巧：双重表示法和记忆术，的特定应用。


在首个方案中，我们使用一个弱表，来将每个表映射到其默认值：


```lua
local defaults = {}
setmetatable(defaults, {__mode = "k"})

local mt = {__index = function (t) return defaults[t] end}

function setDefault (t, d)
    defaults[t] = d
    setmetatable(t, mt)
end
```

这是双重表示法的典型用途，我们使用 `defaults[t]` 表示 `t.default`。如果 `defaults` 表没有弱键，他就会将所有带缺省值的表，锚定为永久存在。


在第二种解决方案中，我们为各异的默认值使用不同元表，不过每当我们重复某个默认值时，都会重用同一个元表。这就是记忆术的典型应用：


```lua
local metas = {}
setmetable(metas, {__mode = "v"})

function setDefaults (t, d)
    local mt = metas[d]
    if mt == nil then
        mt = {__index = function () return d end}
        metas[d] = mt       -- memoize
    end
    setmetatable(t, mt)
end
```


在此情形下，我们使用了弱值，来回收那些不再使用的元表。

有了这两种默认值实现方法，然而哪种最好呢？和往常一样，这取决于具体情况。两者的复杂度和性能都差不多。第一种实现方式需要为每个带有默认值的表（`defaults` 表中的条目）提供少许几个内存字，a few memory words。第二种实现方式则需要数十个内存字，来处理每个不同默认值（一个新表、一个新闭包，外加 `metas` 表中的一个条目）。因此，如果咱们的应用程序有数千个都有数个不同默认值的表，那么第二种实现方式显然更胜一筹。另一方面，如果只有少数几个共用了共同默认值的表，那么咱们应倾向于第一种实现方式。


## 星历表

**Ephemeron Tables**


在有着弱键的表中，当出现某个值指向他自己键时，就会出现棘手的情况。


这种情况比想象中更为常见。一个典型的例子，便是常量函数工厂，a constant-function factor。这种工厂会取个对象，并返回一个每次被调用时，都会返回该对象的函数：

```lua
function factory (o)
    return (function () return o end)
end
```


这种工厂非常适合记忆化，避免了在已有闭包情况下，创建出新的闭包。下图 23.1 “带有记忆功能的恒定函数工厂” 展示了这种改进。


图 23.1，带有记忆术的常量函数工厂，constant-function factory with memorization


```lua
do
    local mem = {}      -- 记忆表
    setmetatable(mem, {__mode "k"})
    
    function factory (o)
        local res = mem[o]
        if not res then
            res = (function () then o end)
            mem[o] = res
        end
        return res
    end
end
```


不过，这里有个问题。请注意，`mem` 中与对象相关联的值（那个常量函数），指向回了其自身的键（对象本身）。虽然表中的键是弱的，但值却不是。根据弱表的标准解释，那个记忆表中的任何东西都不会被删除。因为值不是弱值，所以每个函数都有个强引用，a string reference。每个函数都指向了其对应的对象，因此每个键都有个强引用。因此，尽管存在弱键，这些对象也不会被回收。


然而，这种严格解释并不十分有用。大多数人都认为，表中的值只能通过相应的键来访问。我们可以把上述情况，看作是一种循环，其中闭包指向的对象，又（通过记忆表）又指向回了闭包。


Lua 通过星历表的概念，解决了上述问题[<sup>2</sup>](#footnote_2_187)。在 Lua 中，有着弱键与强值的表，就是 *星历表，ephemeron table*。在星历表中，键的可访问性，控制着其对应值的可访问性。更具体地说，请设想某星历表中的条目 `(k,v)`。只有当 `k` 存在别的外部引用时，对 `v` 的引用才是强引用。否则，垃圾回收器最终将回收 `k` 并从表中删除条目，即使 `v` 直接或间接地引用了 `k`。


<a name="footnote_2_187"><sup>2</sup></a> 星历表是在 Lua 5.2 中引入的。Lua 5.1 仍然存在这里我们描述的问题。

## 终结器

**Finalizers**


虽然垃圾回收器的目标是回收 Lua 对象，但他也可以帮助程序释放外部资源。为此，一些编程语言提供了 *终结器，finalizer*。终结器是个与对象相关联的函数，在对象即将被回收时被调用。


Lua 通过元方法 `__gc` 实现了终结器，如下面的示例所示：


```lua
o = {x = "hi"}
setmetatable(o, {__gc = function (o) print(o.x) end})

o = nil
collectgarbage()    --> hi
```

在本例中，我们首先创建了个表，并赋予他一个有着 `__gc` 元方法的元表。然后，我们擦除了与该表的唯一链接（全局变量 `o`），并强制进行了一次完全的垃圾回收。在回收过程中，Lua 检测到该表已不再可访问，因此就会调用他的终结器 -- `__gc` 元方法。


Lua 中的终结器的一个微妙之处在于，标记终结对象的概念。通过给某个对象设置一个有着非空 `__gc` 元方法的元表，我们标记出要终结的对象。如果我们没有标记对象，那么他就不会被最终化。我们编写的大多数代码，都能自然地工作，但也会出现一些奇怪的情况，比如这里：

```lua
o = {x = "hi"}
mt = {}
setmetatable(o, mt)

mt.__gc = function (o) print(o.x) end

o = nil
collectgarbage()    --> (什么也不会打印)
```


在这里，我们给 `o` 设置的元表，没有 `__gc` 元方法，因此该对象就没有被标记为终结。即使我们后来在元表中，添加了一个 `__gc` 字段，Lua 也不会将该赋值检测为特殊赋值，因此他就不会标记该对象。


正如我们曾说过的，这绝不是个问题；在设置了元表后再更改元方法并不常见。如果随后确实需要设置该元方法，那么可以为 `__gc` 字段提供任何值，以作为占位符：


```lua
o = {x = "hi"}
mt = {__gc = true}
setmetatable(o, mt)

mt.__gc = function (o) print(o.x) end

o = nil
collectgarbage()    --> hi
```


现在，由于元表有了个 `__gc` 字段，`o` 就会被正确地标记为终结。即使咱们以后未设置某个元方法，也不会有问题；Lua 只会在终结器是个恰当的函数时调用他。


当垃圾回收器在同一周期内，会终结多个对象时，他会按照对象被标记为终结的相反顺序，调用他们的终结器。请设想下面这个创建出了带有终结器对象链表的示例：


```lua
mt = {__gc = function (o) print(o[1]) end}

list = nil
for i = 1, 3 do
    list = setmetatable({i, link = list}, mt)
end

list = nil
collectgarbage()
    --> 3
    --> 2
    --> 1
```



