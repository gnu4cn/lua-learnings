# 垃圾回收

**Garbage**


Lua 会进行自动的内存管理。程序可以创建出对象（表、闭包等），却没有删除对象的功能。Lua 会使用 *垃圾回收，garbage collection*，自动删除成为了垃圾的对象。这使我们摆脱了内存管理的大部分负担，更重要的是，使我们摆脱了与内存管理相关的大部分错误，如悬空指针及内存泄漏等，dangling pointers and memory leaks。


在一种理想世界中，程序员是看不到垃圾回收器的，the garbage collector，他就像个优秀的清洁工，不会干扰其他工作人员的工作。不过，有时即使是更聪明的垃圾回收器，也需要我们的帮助。我们可能需要在某些性能关键时刻，停止他工作，或者只允许他在某些特定时间工作。此外，垃圾回收器只能回收他能确定是垃圾的东西，而不能猜度我们认为什么是垃圾。没有垃圾回收器，我们就无法摆脱资源管理方面的所有烦恼，比如内存和外部资源的囤积等，hoarding memory and external resources。


弱表，weak tables、终结器，finalizers，和函数 `collectgarbage` 三者，是我们在 Lua 中，帮助垃圾回收器可以使用的主要机制。弱表实现对程序仍可访问 Lua 对象的回收；终结器实现对不受垃圾回收器直接控制外部对象的回收。函数 `collectgarbage` 则允许我们控制垃圾回收器的运行速度。在本章中，我们将讨论这些机制。



## 弱表

**Weak Tables**


正如我们曾说过的，垃圾回收器不能猜度我们认为的垃圾是什么。典型例子就是堆栈，他是通过一个数组，以及一个指向顶部的索引实现的。我们知道，数组的有效部分只会到顶部，但 Lua 却不知道。如果我们通过简单地递减顶层索引，来弹出一个元素，那么对 Lua 来说，数组中剩下的对象就不是垃圾。同样，存储在某个全局变量中的任何对象，对 Lua 来说都不是垃圾，即使咱们的程序永远不再用到他。在这两种情况下，我们（即我们的程序）都需要为这些位置赋值 `nil`，这样他们就不会锁定本可丢弃的对象。


然而，只是清理咱们的引用，并非总是足够了。有的结构就需要程序和回收器之间，额外的协作。典型例子便是，当我们想要保留程序中某种存活对象（如文件）列表时。此任务看似简单：我们只需将每个新对象，插入该列表即可。但是，一旦对象成为该列表的一部分，他就永远不会被回收！即使没有其他对象指向他，列表也会指向他。除非我们告诉 Lua 没有对象指向他这一事实，否则 Lua 就无法知道，列表指向他这一引用，不应阻止该对象的回收。


弱表正是我们用来告诉 Lua，某个引用不应阻止对象回收的机制。*弱引用，weak reference* 是种垃圾回收器不会考虑的对象引用。如果指向某个对象的全部引用都是弱引用，那么垃圾回收器就会回收该对象，并删除这些弱引用。Lua 通过 *弱表*，实现的弱引用：弱表是种其条目均为弱条目的表。这意味着，如果某个对象只存在于弱表中，那么 Lua 最终将回收该对象。


表有着键与值，两者均可包含任何类型对象。正常情况下，垃圾回收器不会回收作为键或值，出现在某个可访问表中的对象。也就是说，键和值都是强引用，因为他们可以防止回收他们所引用的对象。在弱表中，键和值都可以是弱引用。这就意味着有三种弱表：键为弱的表、值为弱的表以及键和值都为弱的表。不管是哪种表，当键或值被回收时，整个条目都会从表中消失。


??? from here until ???END lines may have been inserted/deleted
表的弱性，是由其元表中的 `__mode` 字段所给出的。如果该字段存在且值为 `"k"`，则表中的键为弱键；如果该字段值为 `"v"`，则表中的值为弱值；如果该字段值为 `"kv"`，则键和值都为弱值。下面的示例虽然是杜撰的，却说明了弱表的基本行为：


```lua
a = {}
mt = {__mode = "k"}
setmetatable(a, mt)     -- 现在 'a' 就有了弱键
key = {}                -- 创建出首个键
a[key] = 1
key = {}                -- 创建出第二个键
a[key] = 2
collectgarbage()        -- 强制进行一次垃圾回收周期
for k, v in pairs(a) do print(v) end
    --> 2
```

在这个示例中，第二个赋值 `key = {}` 覆盖了第一个 `key` 的引用。对 `collectgarbage` 的调用，会强制垃圾回收器进行一次完整的回收。由于不再有其他的对第一个键引用，Lua 就会回收这个键并删除该表中的相应条目。然而，第二个键仍锚定在变量 `key` 中，因此 Lua 不会回收他。


请注意，只有对象才能从弱表中删除。数字和布尔值等值，就不能被回收。例如，如果我们往这个表 `a` （上一示例中），插入一个数字键，那么收集器就永远不会删除他。当然，如果某个数字键对应的值，在某个有着弱值的表中被回收了，那么整个条目就会从该表中被移除。


在这里，字符串有个微妙之处：虽然从实现角度看，字符串是可回收的，但他们却与其他可回收对象不同。其他对象，如表和闭包，都是显式创建的。例如，每当 Lua 计算表达式 `{}` 时，他都会创建一个新表。但是，Lua 在计算 `"a".."b"` 时，会不会创建出新的字符串呢？如果系统中已经有个字符串 `"ab"` 会怎么办呢？Lua 是否会创建一个新的字符串？编译器能否在运行程序之前，创建这个字符串呢？这并不重要：这些都是实现细节。从程序员角度来看，字符串是值，而非对象。因此，与数字或布尔值一样，字符串键不会从弱表中删除，除非其关联的值被回收。


## 记忆函数

**Memorize Functions**


以空间换取时间，是种常见编程技巧。通过 *记住* 某个函数的结果，在以后我们用相同参数调用该函数时，这个函数就可以重复使用该结果[<sup>1</sup>](#footnote_184-1)，如此我们就可以加快某个函数的运行。

<a name="footnote_184-1"><sup>1</sup></a> 尽管 “memorize”（记忆）这一既定的英文单词，恰好描述了我们想要做的事情，但编程界还是创造了个新词 -- *memoize*（记忆）-- 来描述这一技术。我（作者）将坚持使用原词。

设想某个通用服务器正以 Lua 代码，接收着字符串形式的请求。其每次收到请求时，他都会在该字符串上运行 `load` 函数，然后调用生成的函数。然而，`load` 是个开销昂贵的函数，且服务器收到的某些命令可能相当频繁。服务器无需在每次收到像是 `"closeconnection()"` 这样的常见命令时，重复调用 `load`，而是可以使用一个辅助表，来 *记住* `load` 的结果。在调用 `load` 前，服务器会在该表中检查给定字符串是否已有转译。若找不到匹配的结果，服务器就会调用 `load`，并将结果存储到该表中。我们可以将这种行为，打包到一个新函数中：


```lua
local results = {}
function mem_loadstring (s)
    local res = results[s]
    if res == nil then                  -- 结果不存在？
        res = assert(load(s))           -- 计算新的结果
        results[s] = res                -- 保存用于后面的重用
    end
    return res
end
```

这种方案下可以节省大量开销。不过，他也可能造成意想不到的浪费。虽然有些命令会反复出现，但许多其他命令却只会出现一次。逐渐地，表 `results` 会累积下服务器收到过的所有命令及其各自的代码；足够长的时间后，这种行为会耗尽服务器内存。


弱值表为这一问题提供了一种简单解决方案。如果 `results` 表有着弱值，那么每个垃圾回收周期都会删除当时未用到所有转译（这意味着几乎所有转移）：


```lua
local results = {}
setmetatable(results, {__mode = "v"})   -- 使值成为弱值
function mem_loadstring (s)
    as before
```

实际上，由于该表的索引始终是字符串，因此如果我们愿意，可以让这个表完全弱化：

```lua
setmetatable(results, {__mode = "kv"})
```

最终（净）结果是一样的，the net result is the same。


这种记忆技巧，对于确保某种对象的唯一性也很有用。例如，假设某个系统以表的形式表示颜色，其中的 `red`、`green`、`blue` 字段在一定范围内。那么一个简单的颜色工厂，就会为每个新请求生成一种新颜色：

```lua
function createRGB (r, g, b)
    return {red = r, green = g, blue = b}
end
```

运用记忆术，我们可以对相同颜色重用同一个表。要为每种颜色创建一个唯一键，我们只需将颜色索引连接起来，其间用分隔符隔开即可：


```lua
local results = {}
setmetatable(results, {__mode = "v"})   -- 使值成为弱值
function createRGB (r, g, b)
    local key = string.format("%d-%d-%d", r, g, b)
    local color = results[key]
    if color == nil then
        color = {red = r, green = g, blue = b}
        results[key] = color
    end
    return color
end
```

这种实现方式的一个有趣结果是，用户可以使用原始相等运算符，the primitive equality operator，`==`，来比较颜色，这是因为两种共存的相等颜色，总是由同一个表来表示的。任何给定颜色，都可以在不同时间由不同表来表示，因为垃圾回收器会不时清除那个 `results` 表。不过，只要给定颜色仍在使用中，其就不会从 `results` 中删除。因此，只要某种颜色存活时间足够长，其就可以与某种新的颜色进行比较，其的表示也就存活了足够长的时间，可以被新颜色重用。


## 对象属性

**Object Attributes**


弱表的另一重要用途，是将属性与对象关联起来。很多情况下，我们都需要为对象附加一些属性：函数的名字、表格的默认值及数组的大小等等。

当对象是个表时，我们就可以适当的唯一键，在表中存储属性。(正如我们之前所看到的，创建唯一键的一种简单且不会出错的方法，便是创建一个新表并将其作为键）。但是，如果对象不是表，其就不能保留自己的属性。即使是表，有时我们可能也不想在原始对象中存储属性。例如，我们可能打算将属性保持私有，或者不想让属性干扰表的遍历等等。在所有这些情况下，我们就需要某种将属性映射到对象的替代方法。


当然，外部表提供了一种将属性映射到对象的理想方式。这就是我们在 [“双重表示法”](oop.md#双重表示法) 小节中，所说的 *双重表示法，dual representation*。我们将对象用作键，将其属性作为值。由于 Lua 允许我们使用任何类型对象作为键，因此外部表就可以保存任何类型对象的属性。此外，外部表中保存的属性，还不会干扰其他对象，并且可以像表本身一样私有。


然而，这个看似完美的解决方案，却有个巨大的缺陷：一旦我们将某个对象用作某个表的键，我们就会锁定该对象的存在。Lua 无法回收被用作键的对象。例如，如果我们使用某个常规表，将函数映射到他们的名字，那么这些函数将永远不会被回收。正如咱们所料，我们可以通过使用弱表，来避免这一缺点。不过，这次我们需要弱键。弱键的使用，不会阻止任何键被回收，直到没有对该键的任何引用，the use of weak keys does not prevent any key from being collected, once there are no other references to it。另一方面，该表不能有弱值；否则，存活对象的属性会被回收掉。


## 重温带默认值的表

**Revisiting Tables with Default Values**


在名为 [带默认值的表](metatables_and_metamethods.md#带默认值的表) 小节，我们讨论过如何实现带非空，non-nil，缺省值的表。我们曾见识到一种特别技巧，并提到另外两种技巧需要用到弱表，因此我们推迟了对这两种技巧的讨论。现在是重新讨论这个问题的时候了。我们将看到，这两种缺省值技巧，实际上是我们刚讨论过的两种一般技巧：双重表示法和记忆术，的特定应用。


在首个方案中，我们使用一个弱表，来将每个表映射到其默认值：


```lua
local defaults = {}
setmetatable(defaults, {__mode = "k"})

local mt = {__index = function (t) return defaults[t] end}

function setDefault (t, d)
    defaults[t] = d
    setmetatable(t, mt)
end
```

这是双重表示法的典型用途，我们使用 `defaults[t]` 表示 `t.default`。如果 `defaults` 表没有弱键，他就会将所有带缺省值的表，锚定为永久存在。


在第二种解决方案中，我们为各异的默认值使用不同元表，不过每当我们重复某个默认值时，都会重用同一个元表。这就是记忆术的典型应用：


```lua
local metas = {}
setmetable(metas, {__mode = "v"})

function setDefaults (t, d)
    local mt = metas[d]
    if mt == nil then
        mt = {__index = function () return d end}
        metas[d] = mt       -- memoize
    end
    setmetatable(t, mt)
end
```


在此情形下，我们使用了弱值，来回收那些不再使用的元表。

有了这两种默认值实现方法，然而哪种最好呢？和往常一样，这取决于具体情况。两者的复杂度和性能都差不多。第一种实现方式需要为每个带有默认值的表（`defaults` 表中的条目）提供少许几个内存字，a few memory words。第二种实现方式则需要数十个内存字，来处理每个不同默认值（一个新表、一个新闭包，外加 `metas` 表中的一个条目）。因此，如果咱们的应用程序有数千个都有数个不同默认值的表，那么第二种实现方式显然更胜一筹。另一方面，如果只有少数几个共用了共同默认值的表，那么咱们应倾向于第一种实现方式。



