# 垃圾回收

**Garbage**


Lua 会进行自动的内存管理。程序可以创建出对象（表、闭包等），却没有删除对象的功能。Lua 会使用 *垃圾回收，garbage collection*，自动删除成为了垃圾的对象。这使我们摆脱了内存管理的大部分负担，更重要的是，使我们摆脱了与内存管理相关的大部分错误，如悬空指针及内存泄漏等，dangling pointers and memory leaks。


在一种理想世界中，程序员是看不到垃圾回收器的，the garbage collector，他就像个优秀的清洁工，不会干扰其他工作人员的工作。不过，有时即使是更聪明的垃圾回收器，也需要我们的帮助。我们可能需要在某些性能关键时刻，停止他工作，或者只允许他在某些特定时间工作。此外，垃圾回收器只能回收他能确定是垃圾的东西，而不能猜度我们认为什么是垃圾。没有垃圾回收器，我们就无法摆脱资源管理方面的所有烦恼，比如内存和外部资源的囤积等，hoarding memory and external resources。


弱表，weak tables、终结器，finalizers，和函数 `collectgarbage` 三者，是我们在 Lua 中，帮助垃圾回收器可以使用的主要机制。弱表实现对程序仍可访问 Lua 对象的回收；终结器实现对不受垃圾回收器直接控制外部对象的回收。函数 `collectgarbage` 则允许我们控制垃圾回收器的运行速度。在本章中，我们将讨论这些机制。



## 弱表

**Weak Tables**


正如我们曾说过的，垃圾回收器不能猜度我们认为的垃圾是什么。典型例子就是堆栈，他是通过一个数组，以及一个指向顶部的索引实现的。我们知道，数组的有效部分只会到顶部，但 Lua 却不知道。如果我们通过简单地递减顶层索引，来弹出一个元素，那么对 Lua 来说，数组中剩下的对象就不是垃圾。同样，存储在某个全局变量中的任何对象，对 Lua 来说都不是垃圾，即使咱们的程序永远不再用到他。在这两种情况下，我们（即我们的程序）都需要为这些位置赋值 `nil`，这样他们就不会锁定本可丢弃的对象。


然而，只是清理咱们的引用，并非总是足够了。有的结构就需要程序和回收器之间，额外的协作。典型例子便是，当我们想要保留程序中某种存活对象（如文件）列表时。此任务看似简单：我们只需将每个新对象，插入该列表即可。但是，一旦对象成为该列表的一部分，他就永远不会被回收！即使没有其他对象指向他，列表也会指向他。除非我们告诉 Lua 没有对象指向他这一事实，否则 Lua 就无法知道，列表指向他这一引用，不应阻止该对象的回收。



