# 反射

**Reflection**


反射，是指程序检查、修改其自身执行某些方面的能力。动态语言（如 Lua）自然而然支持多种反射特性：

- 环境特性允许了运行时的全局变量检查；
- 函数（如 `type` 和 `pairs`）允许了运行时的未知数据结构检查和遍历；
- 函数（如 `load` 和 `require`）允许了程序为自身添加代码或更新自己的代码。


然而，仍有许多不足之处：程序无法自省其局部变量，程序无法跟踪其执行情况，函数无法获悉其调用者，等等。调试库，the debug library，填补了这些空白。


调试库包含两类函数：*内省函数，introspective functions* 和 *钩子，hooks*。内省函数允许我们检查正在运行程序的多个方面，譬如活动函数堆栈、当前执行行及局部变量的值和名称等。钩子允许我们跟踪程序的执行。


尽管名为调试库，但他并未提供一个 Lua 调试器。不过，他提供了编写我们自己调试器所需的，复杂程度各不相同的全部原语。


与其他库不同，我们应该谨慎使用调试库，use the debug library with parsimony。首先，调试库的某些功能，并不以性能著称。其次，他打破了该门语言的一些神圣真理，比如我们不能从局部变量的词法范围之外，访问该局部变量这一条。虽然调试库与标准库一样直接可用，但我（作者）更倾向于，在任何用到调试库的代码块中，显式地导入他。



## 自省设施

**Introspective Facilities**


调试库中的主要自省函数，是 `getinfo`。其第一个参数可以是某个函数，也可以是某个堆栈层级，a stack level。当我们对函数 `foo` 调用 `debug.getinfo(foo)` 时，他会返回一个包含有关该函数一些数据的表。该表可以包含以下字段：


- `source`：该字段给出函数于何处定义。如果函数是在字符串中定义的（经由一个 `load` 调用），那么 `source` 就是那个字符串。如果函数是在某个文件中定义的，那么 `source` 就是以 `@` 符号为前缀的文件名；

- `short_src`：该字段是 `source` 简短版本（最多 60 个字符）。这对于错误信息非常有用；

- `linedefined`：该字段给出了定义函数的源代码第一行编号；

- `lastlinedefined`：该字段给出了定义函数的源代码最后一行编号；

- `what`：该字段给出了此函数是什么。如果 `foo` 是个常规 Lua 函数，则选项为 `Lua`；如果是个 C 函数，则选项为 `C`；如果是 Lua 代码块的主要部分，则选项为 `main`；

- `name`：该字段给到函数的合理名称，例如存储该函数的全局变量名称；

- `namewhat`：该字段给出前一字段的含义。该字段可以是 `global`、`local`、`method`、`field` 或 ``（空字符串）。空字符串表示 Lua 没有找到函数名称；

- `nups`：这是该函数的上值个数，the number of upvalues；

- `nparams`：这是该函数的参数个数；

- `isvararg`：这表明函数是否为可变参数，whether the function is variadic（一个布尔值）；

- `activelines`：该字段是个表示函数活动行集合的表。所谓 *活动行，active line*，是指有代码的行，而不是空行或仅包含注释的行。(该信息的一个典型用途，是设置断点。大多数调试器不允许我们在活动行之外设置断点，因为这样的断点是无法到达的。）

- `func`：该字段为函数本身。



